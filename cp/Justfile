#!/usr/bin/env just --justfile

set shell := ["bash", "-euo", "pipefail", "-c"]
set export

script_path := justfile_directory()

# Default recipe - shows available commands
default:
    @just --list

# ============================================================================
# INFRASTRUCTURE
# ============================================================================

# Provision VM infrastructure
vm:
    #!/usr/bin/env bash
    set -e
    echo "Provisioning VM infrastructure..."
    cd {{ script_path }}/terraform
    terraform init
    terraform apply -auto-approve
    echo "Infrastructure provisioned successfully!"

# Destroy all infrastructure
destroy:
    #!/usr/bin/env bash
    set -e
    echo "Destroying VM infrastructure..."
    cd {{ script_path }}/terraform
    terraform destroy -auto-approve
    echo "Infrastructure destroyed!"

# ============================================================================
# INTERNAL HELPERS (prefixed with _)
# ============================================================================

# Get recovery status for a node (outputs: t, f, or error)
_recovery-status node:
    #!/usr/bin/env bash
    result=$(echo "SELECT pg_is_in_recovery();" | just exec-psql {{ node }} postgres 2>/dev/null | grep -E '^ (t|f)' | tr -d ' ')
    [ -z "$result" ] && result="error"
    echo "$result"

# Detect topology - outputs eval-able: DC1=x DC2=x PRIMARY=x STANDBY=x STATUS=x
_detect-topology:
    #!/usr/bin/env bash
    DC1=$(just _recovery-status dc1)
    DC2=$(just _recovery-status dc2)

    if [ "$DC1" = "f" ] && [ "$DC2" = "t" ]; then
        echo "DC1=$DC1 DC2=$DC2 PRIMARY=dc1 STANDBY=dc2 STATUS=ok"
    elif [ "$DC2" = "f" ] && [ "$DC1" = "t" ]; then
        echo "DC1=$DC1 DC2=$DC2 PRIMARY=dc2 STANDBY=dc1 STATUS=ok"
    elif [ "$DC1" = "f" ] && [ "$DC2" = "f" ]; then
        echo "DC1=$DC1 DC2=$DC2 PRIMARY=dc1 STANDBY=dc2 STATUS=split-brain"
    elif [ "$DC1" = "f" ] && [ "$DC2" = "error" ]; then
        echo "DC1=$DC1 DC2=$DC2 PRIMARY=dc1 STANDBY=dc2 STATUS=standby-down"
    elif [ "$DC2" = "f" ] && [ "$DC1" = "error" ]; then
        echo "DC1=$DC1 DC2=$DC2 PRIMARY=dc2 STANDBY=dc1 STATUS=standby-down"
    elif [ "$DC1" = "t" ] && [ "$DC2" = "t" ]; then
        echo "DC1=$DC1 DC2=$DC2 PRIMARY=unknown STANDBY=unknown STATUS=no-primary"
    else
        echo "DC1=$DC1 DC2=$DC2 PRIMARY=unknown STANDBY=unknown STATUS=unknown"
    fi

# Run kubectl on remote instance
_kubectl instance_name +args:
    #!/usr/bin/env bash
    set -e
    cd {{ script_path }}/terraform
    IP=$(terraform output -json instance_ipv4s | jq -r '.["{{ instance_name }}"]')
    USER=$(terraform output -json instance_usernames | jq -r '.["{{ instance_name }}"]')
    PORT=$(terraform output -json instance_ssh_ports | jq -r '.["{{ instance_name }}"]')
    ssh -p $PORT $USER@$IP "KUBECONFIG=/home/debian/.kube/config kubectl {{ args }}"

# ============================================================================
# SSH & CONNECTION HELPERS
# ============================================================================

# Wait for host and accept SSH key
wait-and-accept instance_name: vm
    #!/usr/bin/env bash
    set -e
    cd {{ script_path }}/terraform
    IP=$(terraform output -json instance_ipv4s | jq -r '.["{{ instance_name }}"]')
    PORT=$(terraform output -json instance_ssh_ports | jq -r '.["{{ instance_name }}"]')

    if [ "$IP" = "null" ] || [ -z "$IP" ]; then
        echo "Instance '{{ instance_name }}' not found in terraform outputs"
        exit 1
    fi

    echo "Waiting for ${IP} to become available on port ${PORT}..."
    while ! (echo > /dev/tcp/${IP}/${PORT}) 2>/dev/null; do
        sleep 1
    done
    echo "${IP} is now available"

    # Remove old fingerprint if exists and accept new one
    ssh-keygen -F ${IP} > /dev/null 2>&1 && ssh-keygen -R ${IP}
    ssh-keyscan -H -p ${PORT} ${IP} >> ~/.ssh/known_hosts
    echo "SSH key accepted"

# Connect to instance via SSH
connect instance_name: (wait-and-accept instance_name)
    #!/usr/bin/env bash
    set -e
    cd {{ script_path }}/terraform
    IP=$(terraform output -json instance_ipv4s | jq -r '.["{{ instance_name }}"]')
    USER=$(terraform output -json instance_usernames | jq -r '.["{{ instance_name }}"]')
    PORT=$(terraform output -json instance_ssh_ports | jq -r '.["{{ instance_name }}"]')
    ssh -p ${PORT} ${USER}@${IP}

# Execute shell command on instance
exec-ssh instance_name cmd:
    #!/usr/bin/env bash
    set -e
    cd {{ script_path }}/terraform
    IP=$(terraform output -json instance_ipv4s | jq -r '.["{{ instance_name }}"]')
    USER=$(terraform output -json instance_usernames | jq -r '.["{{ instance_name }}"]')
    PORT=$(terraform output -json instance_ssh_ports | jq -r '.["{{ instance_name }}"]')
    ssh -p $PORT $USER@$IP "{{ cmd }}"

# ============================================================================
# POSTGRESQL HELPERS
# ============================================================================

# Wait for PostgreSQL pod to be ready
wait-for-postgres instance_name:
    #!/usr/bin/env bash
    set -e
    echo "Waiting for PostgreSQL pod on {{ instance_name }} to be ready..."
    while ! just _kubectl {{ instance_name }} get pod postgresql-0 -n postgresql 2>/dev/null | grep -q "1/1.*Running"; do
        echo "   Waiting for postgresql-0 pod on {{ instance_name }}..."
        sleep 2
    done
    echo "PostgreSQL pod on {{ instance_name }} is ready"

    echo "Waiting for PostgreSQL service on {{ instance_name }} to accept connections..."
    while ! just _kubectl {{ instance_name }} exec postgresql-0 -n postgresql -- bash -c 'PGPASSWORD="Test_Password123!" psql -U postgres -d postgres -c "SELECT 1" > /dev/null 2>&1'; do
        echo "   Waiting for PostgreSQL service on {{ instance_name }}..."
        sleep 2
    done
    echo "PostgreSQL service on {{ instance_name }} is accepting connections"

# Execute PostgreSQL command (pipe SQL via stdin, or pass sql_file)
exec-psql instance_name database sql_file="":
    #!/usr/bin/env bash
    set -e
    cd {{ script_path }}/terraform
    IP=$(terraform output -json instance_ipv4s | jq -r '.["{{ instance_name }}"]')
    USER=$(terraform output -json instance_usernames | jq -r '.["{{ instance_name }}"]')
    PORT=$(terraform output -json instance_ssh_ports | jq -r '.["{{ instance_name }}"]')

    PSQL_OPTS="-e -v ON_ERROR_STOP=1"

    if [ -z "{{ sql_file }}" ]; then
        ssh -p $PORT $USER@$IP \
            "KUBECONFIG=/home/debian/.kube/config kubectl exec -i postgresql-0 -n postgresql -- bash -c 'PGPASSWORD=\"Test_Password123!\" psql $PSQL_OPTS -U postgres -d {{ database }}'"
    else
        cat {{ script_path }}/{{ sql_file }} | ssh -p $PORT $USER@$IP \
            "KUBECONFIG=/home/debian/.kube/config kubectl exec -i postgresql-0 -n postgresql -- bash -c 'PGPASSWORD=\"Test_Password123!\" psql $PSQL_OPTS -U postgres -d {{ database }}'"
    fi

# ============================================================================
# INITIAL SETUP
# ============================================================================

# Setup primary node (dc1)
setup-primary: (wait-and-accept "dc1") (wait-for-postgres "dc1")
    #!/usr/bin/env bash
    set -e
    echo "Setting up primary node (dc1)..."

    echo "Running postgres-setup.sql on dc1..."
    just exec-psql dc1 postgres sql/common/postgres-setup.sql

    echo "Running schema.sql on dc1..."
    just exec-psql dc1 my_db sql/templates/schema.sql

    echo "Running sample-data.sql on dc1..."
    just exec-psql dc1 my_db sql/data/sample-data.sql

    echo "Primary node (dc1) setup complete!"

# Setup standby node (dc2) - clones from primary using pg_basebackup
setup-standby: (wait-and-accept "dc2") (wait-for-postgres "dc2")
    #!/usr/bin/env bash
    set -e
    echo "Setting up standby node (dc2)..."

    cd {{ script_path }}/terraform
    DC1_IP=$(terraform output -json instance_ipv4s | jq -r '.["dc1"]')

    echo "Primary (dc1) IP: $DC1_IP"

    echo "Stopping PostgreSQL pod on dc2..."
    just _kubectl dc2 scale statefulset postgresql -n postgresql --replicas=0
    sleep 5

    echo "Running pg_basebackup to clone from primary..."
    just _kubectl dc2 delete job pg-basebackup -n postgresql --ignore-not-found
    sed "s/PLACEHOLDER/$DC1_IP/" {{ script_path }}/manifests/pg-basebackup-job.yaml | \
        just _kubectl dc2 apply -f -

    just _kubectl dc2 wait --for=condition=complete job/pg-basebackup -n postgresql --timeout=300s
    just _kubectl dc2 logs job/pg-basebackup -n postgresql

    echo "Starting PostgreSQL pod on dc2..."
    just _kubectl dc2 scale statefulset postgresql -n postgresql --replicas=1

    just wait-for-postgres dc2
    echo "Standby node (dc2) setup complete!"

# Full replication setup - primary then standby with sync replication
setup-replication: setup-primary setup-standby
    #!/usr/bin/env bash
    set -e
    echo ""
    # -------------------------------------------------------------------------
    # CAP TRADEOFF: Synchronous vs Asynchronous Replication
    # -------------------------------------------------------------------------
    # SYNCHRONOUS (CP - Consistency + Partition tolerance):
    #   - Primary waits for standby to confirm writes
    #   - Zero data loss on failover
    #   - Primary blocks if standby is unreachable
    #
    # ASYNCHRONOUS (faster, but may lose recent commits on failover):
    #   - Primary doesn't wait for standby
    #   - Lower latency, higher throughput
    #   - Recent transactions may be lost if primary dies
    #   - To use async: comment out the ALTER SYSTEM line below
    # -------------------------------------------------------------------------
    echo "Enabling synchronous replication..."
    echo "ALTER SYSTEM SET synchronous_standby_names = 'walreceiver';" | just exec-psql dc1 postgres
    echo "SELECT pg_reload_conf();" | just exec-psql dc1 postgres

    echo ""
    echo "============================================"
    echo "Streaming replication setup complete!"
    echo "============================================"
    just status

# ============================================================================
# OPERATIONS
# ============================================================================

# Check replication status (auto-detects topology)
status:
    #!/usr/bin/env bash
    set -e
    eval $(just _detect-topology)

    [ "$STATUS" = "split-brain" ] && echo "WARNING: Both nodes are primaries (split-brain)"
    [ "$STATUS" = "unknown" ] && echo "WARNING: Could not determine topology"

    echo ""
    echo "=== Primary ($PRIMARY) - pg_stat_replication ==="
    just exec-psql $PRIMARY postgres sql/templates/verify-replication.sql || true

    echo ""
    echo "=== Standby ($STANDBY) - pg_stat_wal_receiver ==="
    echo "SELECT * FROM pg_stat_wal_receiver;" | just exec-psql $STANDBY postgres || true

# Manual failover - promote standby to primary
failover:
    #!/usr/bin/env bash
    set -e
    echo "MANUAL FAILOVER PROCEDURE"
    echo "========================="
    echo ""

    echo "Detecting current topology..."
    eval $(just _detect-topology)
    echo "  dc1 in recovery: $DC1"
    echo "  dc2 in recovery: $DC2"
    echo ""

    # Validate we can failover
    case "$STATUS" in
        split-brain)
            echo "ERROR: Both nodes are primaries (split-brain). Manual intervention required."
            exit 1 ;;
        no-primary)
            echo "ERROR: Both nodes are standbys. No primary available."
            exit 1 ;;
        unknown)
            echo "ERROR: Could not determine topology. Check node connectivity."
            exit 1 ;;
    esac

    echo "Current topology: $PRIMARY is primary, $STANDBY is standby"
    echo ""

    echo "Step 1: Verify standby is caught up..."
    just status

    echo ""
    echo "Step 2: Stopping old primary ($PRIMARY) to prevent split-brain..."
    just _kubectl $PRIMARY scale statefulset postgresql -n postgresql --replicas=0

    echo ""
    echo "Step 3: Promoting $STANDBY to primary..."
    echo "SELECT pg_promote();" | just exec-psql $STANDBY postgres

    echo ""
    echo "Step 4: Waiting for promotion to complete..."
    while [ "$(just _recovery-status $STANDBY)" = "t" ]; do
        sleep 1
    done
    echo "Promotion complete."

    echo ""
    echo "Step 5: Disabling synchronous replication (no standby available)..."
    echo "ALTER SYSTEM SET synchronous_standby_names = '';" | just exec-psql $STANDBY postgres
    echo "SELECT pg_reload_conf();" | just exec-psql $STANDBY postgres

    echo ""
    echo "Failover complete! $STANDBY is now primary, $PRIMARY is stopped."
    echo ""
    echo "Next step: Rebuild $PRIMARY as standby:"
    echo "  just rebuild-standby $PRIMARY"

# Rebuild a node as standby of the current primary
rebuild-standby node:
    #!/usr/bin/env bash
    set -e
    echo "REBUILD STANDBY: {{ node }}"
    echo "=========================="
    echo ""

    eval $(just _detect-topology)

    # Determine primary with special handling for rebuild scenarios
    case "$STATUS" in
        ok)
            ;; # PRIMARY already set correctly
        split-brain)
            # The node we're NOT rebuilding becomes the primary
            if [ "{{ node }}" = "dc1" ]; then
                PRIMARY="dc2"
            else
                PRIMARY="dc1"
            fi
            echo "WARNING: Split-brain detected. Treating $PRIMARY as primary."
            ;;
        standby-down)
            echo "Note: Standby is down, $PRIMARY is primary."
            ;;
        *)
            echo "ERROR: Could not find a primary node (both in recovery or unreachable)."
            exit 1
            ;;
    esac

    echo "Primary is: $PRIMARY"
    echo "Rebuilding {{ node }} as standby..."
    echo ""

    cd {{ script_path }}/terraform
    PRIMARY_IP=$(terraform output -json instance_ipv4s | jq -r ".[\"$PRIMARY\"]")
    echo "Primary IP: $PRIMARY_IP"

    echo "Stopping PostgreSQL on {{ node }}..."
    just _kubectl {{ node }} scale statefulset postgresql -n postgresql --replicas=0
    sleep 5

    echo "Ensuring replication slot exists on $PRIMARY..."
    echo "DO \$\$ BEGIN IF NOT EXISTS (SELECT FROM pg_replication_slots WHERE slot_name = 'standby1_slot') THEN PERFORM pg_create_physical_replication_slot('standby1_slot'); END IF; END \$\$;" | just exec-psql $PRIMARY postgres

    echo "Running pg_basebackup from $PRIMARY..."
    just _kubectl {{ node }} delete job pg-basebackup -n postgresql --ignore-not-found
    sed "s/PLACEHOLDER/$PRIMARY_IP/" {{ script_path }}/manifests/pg-basebackup-job.yaml | \
        just _kubectl {{ node }} apply -f -

    just _kubectl {{ node }} wait --for=condition=complete job/pg-basebackup -n postgresql --timeout=300s
    just _kubectl {{ node }} logs job/pg-basebackup -n postgresql

    echo "Starting PostgreSQL on {{ node }}..."
    just _kubectl {{ node }} scale statefulset postgresql -n postgresql --replicas=1

    just wait-for-postgres {{ node }}

    echo ""
    # See setup-replication for sync vs async tradeoff
    echo "Re-enabling synchronous replication on $PRIMARY..."
    echo "ALTER SYSTEM SET synchronous_standby_names = 'walreceiver';" | just exec-psql $PRIMARY postgres
    echo "SELECT pg_reload_conf();" | just exec-psql $PRIMARY postgres

    echo ""
    echo "{{ node }} rebuilt as standby of $PRIMARY"
    just status

# ============================================================================
# TESTING & VERIFICATION
# ============================================================================

# Verify data is replicated on both nodes
verify-data:
    #!/usr/bin/env bash
    set -e
    echo ""
    echo "=== Data on dc1 ==="
    echo "SELECT * FROM users; SELECT * FROM orders;" | just exec-psql dc1 my_db || true

    echo ""
    echo "=== Data on dc2 ==="
    echo "SELECT * FROM users; SELECT * FROM orders;" | just exec-psql dc2 my_db || true

# Insert test data on current primary
insert-test:
    #!/usr/bin/env bash
    set -e
    eval $(just _detect-topology)

    case "$STATUS" in
        split-brain)
            echo "ERROR: Both nodes are primaries (split-brain). Run 'just rebuild-standby <node>' first."
            exit 1 ;;
        no-primary|unknown)
            echo "ERROR: Could not determine primary. Check node connectivity."
            exit 1 ;;
    esac

    echo "Inserting test row on primary ($PRIMARY)..."
    echo "INSERT INTO users (email, name) VALUES ('test-$(date +%s)@example.com', 'Test User');" | just exec-psql $PRIMARY my_db
    echo "Done. Run 'just verify-data' to see replication."
